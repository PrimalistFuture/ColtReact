<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Hooks</title>
</head>

<body>
    <h1>React Hooks</h1>

    <p>Hooks allow you to get into the internal magic of React, which is more powerful and still reusable. Hooks are the
        future of React, though as we have seen the class based structure of React is still around. I was taught React
        Hooks in Rithm, and it is pretty damn similar.</p>

    <p>With Hooks, you write functional components rather than class based components.</p>

    <h2>useState</h2>

    <p>useState is a function that initializes our state, and returns to us first a variable to access the state, and
        second a
        function to change the state.</p>

    <h2>useEffect Hook</h2>

    <p>When we built class based components we used a bunch of lifecycle methods like componentDidMount,
        componentDidUpdate and componentWillUnmount. Those are not available to use with hooks.</p>

    <p>But we can achieve the same functionality with useEffect. Whatever code is in there, will be run after every
        single render, including the very first.</p>

    <p>Commonly used when getting info from a DB, API or saving something. In a class based component, this would be
        accomplished with a callback function that would run after the state had been set.</p>

    <p>If useEffect is changing a piece of state, it will trigger a re-render, which will trigger another re-render and
        so on. Infinite loops very easily.</p>

    <p>To get around this, you can pass in a second argument to useEffect as an array containing a piece of data in the
        state that will trigger useEffect.</p>

</body>

</html>